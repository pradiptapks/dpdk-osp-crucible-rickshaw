#!/bin/bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4 -*-
exec 2>&1
test -e /etc/profile && . /etc/profile


# Depending on how client-server-script is started, "/usr/local/bin" is not
# always in the $PATH
PATH="/usr/local/bin:$PATH"

max_rb_attempts=5
rb_exit_timeout=3
rb_exit_abort=4
rb_exit_nonet=5
default_timeout=240
client_server_script_timeout=720
runtime_padding=120

function exit_error() {
    local message=$1; shift
    local code=$1; shift
    echo -e "[ERROR]$message\n"
    echo "Exiting"
    if [ -z "$code" ]; then
        exit 1
    else
        exit $code
    fi
}

function do_roadblock() {
    local label=$1; shift
    local leader=$1; shift
    local timeout=$1; shift
    local extra=$1; shift
    if [ -z "$label" ]; then
        exit_error "[ERROR]do_roadblock() label not provided"
    fi
    if [ -z "$timeout" ]; then
        exit_error "[ERROR]do_roadblock() timeout not provided"
    fi
    local msgs_file="$roadblock_msgs_dir/$label.json"
    local cmd=""
    local role="follower"
    cmd="$cmd $roadblock_bin --role=follower --redis-server=$roadblock_server"
    cmd="$cmd --leader-id=$leader --timeout=$timeout --redis-password=$roadblock_passwd"
    #cmd="$cmd --uuid=$roadblock_id:$label --follower-id=$cs_label --message-log=$msgs_file $extra"
    cmd="$cmd --follower-id=$cs_label --message-log=$msgs_file $extra"
    local uuid="$roadblock_id:$label"
    printf "\n\n"
    echo "Starting roadblock [`date`]"
    echo "role: $role"
    echo "uuid (without attempt ID embedded): $uuid"
    echo "timeout: $timeout"

    local attempts=0
    local rc=99
    if [ "$use_roadblock" == "1" ]; then
        while [ $attempts -lt $max_rb_attempts -a $rc -ne 0 -a $rc -ne $rb_exit_abort ]; do
	        let attempts=$attempts+1
            echo "attempt number: $attempts"
            echo "uuid: $attempts:$uuid"
            #echo "going to run this roadblock command: $cmd"
            local output=`$cmd --uuid=$attempts:$uuid 2>&1`
            rc=$?
            echo "roadblock output BEGIN"
            printf "%s" "$output"
            echo "roadblock output END"
            echo "roadblock exit code: $rc"
            if echo $output | grep -q -P -- '(Name\sor\sservice\snot\sknown)'; then
                rc=$rb_exit_nonet
                #rb_exit_msg="Roadblock error: $output"
            elif echo $output | grep -q -P -- '(Exiting\swith\sabort|Roadblock\sCompleted\swith\san\sAbort)'; then
                rc=$rb_exit_abort
                #rb_exit_msg="Roadblock error: $output"
            elif echo $output | grep -q -P -- '(The\sroadblock\shas\stimed\sout|ERROR:\sRoadblock\sfailed\swith\stimeout)'; then
                rc=$rb_exit_timeout
                #rb_exit_msg="Roadblock error: $output"
            fi
            #if [ $rc -gt 0 ]; then
                #echo "Roadblock exit code is non-zero: $rc"
	            #echo "$rb_exit_msg"
            #fi
            if [ -f roadblock-messages ]; then
                echo "messages from roadblock:"
                cat roadblock-messages
            fi
        done

        echo "total attempts: $attempts"
        echo "Completed roadblock [`date`]"
        printf "\n\n"

    else
        return 0
    fi

    if [ $rc -eq 0 -o $rc -eq $rb_exit_abort ]; then
        return $rc
    else
        exit_error "$rb_exit_msg"
    fi
}

function archive_to_controller() {
    local ssh_id_file=$1; shift
    local src=$1; shift # a directory to archive from
    local dest=$1; shift # a destination directory to write archive
    local ssh_attempts=1
    local ssh_rc=1
    local max_attempts=10
    if [ -z "$ssh_id_file" ]; then
        exit_error "archive_to_controller(): ssh_id_file not defined"
    fi
    if [ -z "$src" ]; then
        exit_error "archive_to_controller(): src_file not defined"
    fi
    if [ -z "$dest" ]; then
        exit_error "archive_to_controller(): destination is not defined"
    fi
    pushd $src || exit_error "Could not chdir to $src"
    while [ $ssh_rc -gt 0 -a $ssh_attempts -lt $max_attempts ]; do
        echo "Trying to tar/ssh fron $src to $rickshaw_host:$dest"
        tar czf - . | ssh \
                       -o StrictHostKeyChecking=no \
                       -o ConnectionAttempts=10 \
                       -i "/tmp/rickshaw_id.rsa" \
                       $rickshaw_host "dd of=$dest"
        ssh_rc=$?
        echo "ssh exit code: $ssh_rc"
        if [ $ssh_rc -gt 0 ]; then
            echo "tar/ssh failed, trying again"
            sleep $ssh_attempts
        fi
        let ssh_attempts=$ssh_attempts+1
    done
    popd >/dev/null
    if [ $ssh_attempts -ge $max_attempts ]; then
        exit_error "Could not archive $src to $rickshaw_host:$dest"
    fi
}

echo "client-server-script env:"
env
echo "client-server-script params:"
echo "$@"
echo
echo os-release:
cat /etc/os-release
echo
echo "uname:"
uname -a
echo
version=20200509
echo "version: $version"
echo
longopts="rickshaw-host:,base-run-dir:,endpoint-run-dir:,cs-label:,roadblock-server:"
longopts="${longopts},roadblock-passwd:,roadblock-id:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    exit_error "\nUnrecognized option specified: $@\n\n"
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --rickshaw-host)
            shift;
            rickshaw_host="$1"
            shift;
            ;;
        --base-run-dir)
            shift;
            base_run_dir=$1
            shift;
            ;;
        --cs-label)
            shift;
            cs_label="$1"
            shift;
            ;;
        --endpoint-run-dir)
            shift;
            endpoint_run_dir="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
            exit_error "Unexpected argument [$1]"
            shift;
            break;
            ;;
    esac
done

if [ -z "$endpoint_run_dir" ]; then
    exit_error "The endpoint run directory (--endpoint-run-dir) was not defined"
fi
if [ -z "$cs_label" ]; then
    exit_error "The client/server label (--cs-label) was not defined"
fi
if echo $cs_label | grep -q -P '^(\w+)-\d+$'; then
    echo "client_label \"$cs_label\" is valid"
else
    exit_error 'cs_label "'$cs_label'" does not adhere to regex /^(\w+)-\d+$/'
fi
export RS_CS_LABEL=$cs_label

# Directories on the client/server
cs_dir="`mktemp -d`"
echo "cs_dir: $cs_dir"
tool_start_cmds="$cs_dir/tool-start"
tool_stop_cmds="$cs_dir/tool-stop"
roadblock_msgs_dir="$cs_dir/roadblock-msgs"
mkdir -p "$roadblock_msgs_dir"
cs_type=`echo $cs_label | awk -F- '{print $1}'`
cs_id=`echo $cs_label | awk -F- '{print $2}'`

# Directories on the controller
config_dir="$base_run_dir/config"
client_server_config_dir="$config_dir/client-server"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
run_dir="$base_run_dir/run"
archives_dir="$run_dir/client-server/archives"

if [ -z "$rickshaw_host" ]; then
	exit_error "Exiting due to rickshaw host not being set"
fi

roadblock_bin="/usr/local/bin/roadblock.py"
use_roadblock=1
if [ -z "$roadblock_server" ]; then
    echo "Cannot use roadblock for synchronizaton because a server was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_id" ]; then
    echo "Cannot use roadblock for synchronizaton because an ID was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_passwd" ]; then
    echo "Cannot use roadblock for synchronizaton because a password was not provided"
    use_roadblock=0
fi

if [ "$use_roadblock" == "1" ]; then
    if [ ! -e $roadblock_bin ]; then
        exit_error "Could not find roadblock binary: $roadblock_bin"
    fi
fi

pushd "$cs_dir" >/dev/null || exit_error "Could not chdir to $cs_dir"

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-start
    do_roadblock $label "controller" $client_server_script_timeout
else
    label=collector-script-start
    do_roadblock $label "endpoint" $client_server_script_timeout
fi

# Get files required to run benchmark and tools
cs_files_list="$cs_type-files-list"
# First get the file that tells us what other files to get
scp_from_controller "$ssh_id_file" "$client_server_config_dir/$cs_files_list" "$cs_files_list"
if [ ! -e "$cs_files_list" ]; then
    exit_error "Could not find $cs_files_list"
fi
dest_file=""
src_file=""
# Now we know what files to get
while read -u 9 line; do
    # $cs_files_list has line like:
    # src=<file>
    # dest=<file>
    # (then repeat)
    if [ -z "$src_file" ]; then
        src_file=`echo $line | grep "^src=" | awk -F= '{print $2}'`
        if [ -z "$src_file" ]; then
            exit_error "source file not found in $cs_type-file-list"
        fi
    else 
        dest_file=`echo $line | grep "^dest=" | awk -F= '{print $2}'`
        if [ -z "$dest_file" ]; then
            exit_error "dest file not found in $cs_type-file-list"
        fi
        scp_from_controller "$ssh_id_file" "$src_file" "$dest_file"
        dest_file=""
        src_file=""
    fi
done 9< "$cs_files_list"

# Get the benchmark and tool commands
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    cs_start_bench_cmds="$cs_label-start-bench.cmds"
    scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/start" "bench-start-cmds"
    if [ ! -e "bench-start-cmds" ]; then
        exit_error "bench cmds file bench-start-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
    fi
    if [ "$cs_type" == "client" -a "$cs_id" == "1" ]; then
        scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/runtime" "bench-runtime-cmds"
    fi
    if [ "$cs_type" == "server" ]; then
        scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/stop" "bench-stop-cmds"
        if [ ! -e "bench-stop-cmds" ]; then
            exit_error "bench cmds file bench-stop-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
        fi
    fi
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/stop" "$tool_stop_cmds"
else
    # non-client/server get tool cmds based on endpoint-specific collector = $cs_label like "worker"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/stop" "$tool_stop_cmds"
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    # Regular clients/servers sync with the controller before starting tools
    label=client-server-start-tools
    do_roadblock $label "controller" $default_timeout
else
    # Non client/servers, "collectors", sync with the endpoint that created them
    # because the controller does not know how many collectors there are, but
    # the endpoint does.
    label=collector-start-tools
    do_roadblock $label "endpoint" $default_timeout
fi

for this_tool_cmds in "$tool_start_cmds" "$tool_stop_cmds"; do
    if [ ! -e $this_tool_cmds ]; then
        exit_error "Tool cmd file $this_tool_cmd was not found"
    fi
done
mkdir -p tool-data
pushd tool-data >/dev/null
while read -u 9 line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    /bin/mkdir -p $tool_name
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done 9<"$tool_start_cmds"
popd >/dev/null

declare -A bench_runtime_cmds
declare -A bench_start_cmds
declare -A bench_stop_cmds
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    count=0
    if [ -e bench-start-cmds ]; then
        while read -u 9 line; do
            bench_start_cmds[$count]="$line"
            let count=$count+1
        done 9< bench-start-cmds
    else
        exit_error "bench-start-cmds not found"
    fi
    count=0
    if [ -e bench-runtime-cmds -a "$cs_id" == 1 ]; then
        while read -u 9 line; do
            bench_runtime_cmds[$count]="$line"
            let count=$count+1
        done 9< bench-runtime-cmds
    fi
fi
if [ "$cs_type" == "server" ]; then
    if [ -e bench-stop-cmds ]; then
        count=0
        while read -u 9 line; do
            bench_stop_cmds[$count]="$line"
            let count=$count+1
        done 9< bench-stop-cmds
    else
        exit_error "bench-stop-cmds not found"
    fi
fi
    
abort_opt=""
# Run the actual tests by processing the commands array
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    abort_run_on_iter_fail=0
    max_sample_failures=5
    timeout=$default_timeout
    len=${#bench_start_cmds[@]}
    quit=0
    for (( i=0; i<$len; i++ )); do
        iter_samp=`echo ${bench_start_cmds[$i]} | awk '{print $1}'`
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        let iter_idx=$iter-1
        sample_failures[$iter_idx]=0
    done
    for (( i=0; i<$len; i++ )); do
        if [ $quit -gt 0 ]; then
            echo "quit = 1 so breaking out of tests"
            break
        fi
        iter_samp=`echo ${bench_start_cmds[$i]} | awk '{print $1}'`
        start_cmd=`echo ${bench_start_cmds[$i]} | sed -e s/^$iter_samp//`
        runtime_cmd=`echo ${bench_runtime_cmds[$i]} | sed -e s/^$iter_samp//`
        if [ "$cs_type" == "server" ]; then
            stop_cmd=`echo ${bench_stop_cmds[$i]} | sed -e s/^$iter_samp//`
        fi
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        let iter_idx=$iter-1
        samp=`echo $iter_samp | awk -F- '{print $2}'`
        iter_samp_dir="$cs_dir/iteration-$iter/sample-$samp"
        cs_msgs_dir="$iter_samp_dir/msgs"
        cs_tx_msgs_dir="$cs_msgs_dir/tx" # Messages a client or server wants to transmit
        cs_rx_msgs_dir="$cs_msgs_dir/rx" # Messages a client or server has received
        this_attempt_num=1
        sample_complete=0
        while [ $sample_complete -eq 0 -a ${sample_failures[$iter_idx]} -lt $max_sample_failures ]; do
            this_attempt_fail=0
            for this_dir in "$iter_samp_dir" "$cs_msgs_dir" "$cs_tx_msgs_dir" "$cs_rx_msgs_dir"; do
                echo "mkdir -p $this_dir"
                mkdir -p "$this_dir" || exit_error "Could not mkdir $this_dir"
            done
            # The following should be replaced by creating hardlinks in each sample
            # dir for each file in $cs_file_list
            find . -mindepth 1 -maxdepth 1 -type f | grep -v -- "$cs_label-stderrout.txt" | \
                grep -v -- "$cs_label-bench.cmds" | grep -v -- "$cs_label-tool.cmds" | \
                grep -v -- "$cs_files_list" | \
                cpio -pdum iteration-$iter/sample-$samp/ ||
                exit_error "Could not copy files from $cs_dir to $iter_samp_dir with find & cpio"
            pushd $iter_samp_dir || exit_error "Could not chdir to $iter_samp_dir"
            echo PWD: `/bin/pwd`
            printf "Sample %d attempt number %d\n" $samp $this_attempt_num
            for sync in server-start endpoint-start client-start client-stop endpoint-stop server-stop; do
                label="${iter}-${samp}-${this_attempt_num}:$sync"
                msgs_file="$roadblock_msgs_dir/$label.json"
                this_timeout=$default_timeout
                if [ ! -z "$runtime_cmd" -a "$sync" == "client-start" -a "$cs_id" == "1" -a "$abort_opt" == "" ]; then
                    user_message_opt=""
                    # Get estimated runtime if possible and send to everyone else
                    echo "going to run this command to get the runtime: $runtime_cmd"
                    runtime=`$runtime_cmd`
                    if [ $? -eq 0  -a ! -z "$runtime" ]; then
                        # Add padding to benchmark runtime to give
                        # enough time for everyone to call roadblock
                        let this_timeout=$runtime+$runtime_padding
                        user_json_file="`mktemp`"
                        echo "adding timeout message to $cs_tx_msgs_dir"
                        echo '{"recipient":{"type":"all","id":"all"},"user-object":{"timeout":"'$this_timeout'"}}' >"$cs_tx_msgs_dir/timeout"
                    fi
                fi
                pending_tx_msgs="`/bin/ls -1 $cs_tx_msgs_dir`"
                if [ ! -z "$pending_tx_msgs" -a "$abort_opt" == "" ]; then
                    echo "Found messages in $cs_tx_msgs_dir, preparing them to send"
                    mkdir -p ${cs_tx_msgs_dir}-sent
                    msgs_json_file="$iter_samp_dir/rb-msgs-$sync"
                    echo "[" >"$msgs_json_file"
                    for msg in $pending_tx_msgs; do
                        # TODO validate JSON schema
                        echo "Adding $msg to $msgs_json_file"
                        cat "$cs_tx_msgs_dir/$msg" >>"$msgs_json_file"
                        /bin/mv "$cs_tx_msgs_dir/$msg" "${cs_tx_msgs_dir}-sent"
                        echo "," >>"$msgs_json_file"
                    done
                    echo '{"recipient":{"type":"all","id":"all"},"user-object":{"sync":"'$sync'"}}]' >>$msgs_json_file
                    echo "full message to send:"
                    cat "$msgs_json_file"
                    # TODO changing this to $extra_opt everywhere
                    abort_opt=" --user-messages=$msgs_json_file"
                fi
                do_roadblock "$label" "controller" $timeout "$abort_opt"
                rb_rc=$?
                cmd_rc=0
                abort_opt=""
                echo roadblock $label exit code: $rb_rc
                if [ $rb_rc -eq $rb_exit_abort ]; then
                    this_attempt_fail=1
                    let sample_failures[$iter_idx]=${sample_failures[$iter_idx]}+1
                    echo -e "\nReceived abort exit code from iteration $iter, sample $samp roadblock"
                    if [ ${sample_failures[$iter_idx]} -ge $max_sample_failures ]; then
                        sample_complete=1
                        printf "[ERROR]All A maximum of %d failures for iteration %d have been reached, failing this iteration\n" \
                               $max_sample_failures $iter
                    fi
                    if [ $abort_run_on_iter_fail -eq 1 ]; then
                        printf "[ERROR]Since this interation failed, skipping all other tests\n"
                        quit=1
                    fi
                    #TODO: Below should not be necessary because the server-stop sync is still run
                    #if [ "$cs_type" == "server" ]; then
                        ## Since this is bailing out early, this is our only chance to stop the server
                        #echo -e "\nAttempting to stop server\n"
                        #$stop_cmd
                    #fi
                else
                    # Allow to break out of inner while loop if no aborts all the way to the last sync
                    if [ $this_attempt_fail -eq 0 ]; then
                        if [ "$sync" == "server-stop" ]; then
                            sample_complete=1
                            let num_fail=$this_attempt_num-1
                            printf "Sample %d completed successfully with %d failed attempts (%d total sample failures for this iteration)\n" \
                                   $samp $num_fail ${sample_failures[$iter_idx]}
                        fi
                    fi
                fi
                if [ $rb_rc -eq 2 ]; then
                    exit_error "roadblock for client-server-start-test:$iter-$samp timed out"
                fi
                timeout=$default_timeout
                if [ -f $msgs_file ]; then
                    count=1
                    if [ $cs_type == "client" ]; then
                        cs_buddy="server-$cs_id"
                    else
                        cs_buddy="client-$cs_id"
                    fi
                    echo "Found messages file: $msgs_file"
		    # First look for a message to "all" but sent by client-server buddy
		    # (to be deprecated)
                    jq -cr '.received[] | select(.payload.sender.id == "'$cs_buddy'" and 
                            .payload.message.command == "user-object") | .payload.message' $msgs_file\
                    | while read line; do
                        msg="$sync:$count"
                        echo "Found user-object message from $cs_buddy: $line"
                        echo "$line" | jq '."user-object"' >"$cs_rx_msgs_dir/$msg"
                        let count=$count+1
                    done
		    # Next look for a message sent specifically to this client/server
                    jq -cr '.received[] | select(.payload.recipient.id == "'$cs_label'" and 
                            .payload.message.command == "user-object") | .payload.message' $msgs_file\
                    | while read line; do
                        msg="$sync:$count"
                        echo "Found user-object message from $cs_buddy: $line"
                        echo "$line" | jq '."user-object"' >"$cs_rx_msgs_dir/$msg"
                        let count=$count+1
                    done
                    # TODO: process the newly created msg files above instead of scanning the entire messages array again
                    next_timeout=`jq -r '.received[] | .payload.message."user-object".timeout ' $msgs_file | grep -v null`
                    jq -r '.received[] | .payload.message."user-object".timeout ' $msgs_file
                    if [ ! -z "$next_timeout" ]; then
                        echo "Applying timeout value of $next_timeout to next roadblock sync"
                        timeout=$next_timeout
                    fi
                fi
                # These combinations don't run a command:
                #  sync=server-start & cs_type=client
                #  sync=client-start & cs_type=server
                #  sync=server-stop & cs_type=client
                if [ "$sync" == "server-start" -a "$cs_type" == "server" ]; then
                    echo "Running $sync command: $start_cmd"
                    $start_cmd
                    cmd_rc=$?
                elif [ "$sync" == "client-start" -a "$cs_type" == "client" ]; then
                    echo "Running $sync command: $start_cmd"
                    $start_cmd
                    cmd_rc=$?
                elif [ "$sync" == "server-stop" -a "$cs_type" == "server" ]; then
                    echo "Running $sync command: $stop_cmd"
                    $stop_cmd
                    cmd_rc=$?
                fi
                if [ $cmd_rc -gt 0 ]; then
                    # An abort message must be sent so the other members know how to procede
                    abort_opt=" --abort"
                    echo -e "\nNon-zero exit code from iteration $iter, sample $samp"
                    echo -e "\nWill send abort message on next roadblock\n"
                    echo -e "\nWill not run remaining tests\n"
                    # Since the rest of the roadblocks for this test will not be done, stop the server now
                    if [ "$cs_type" == "server" ]; then
                        echo -e "\nAttempting to stop server\n"
                        $stop_cmd
                    fi
                fi
            done #for
            if [ $this_attempt_fail -eq 1 ]; then
                /bin/mv "$iter_samp_dir" "$iter_samp_dir-fail${sample_failures[$iter_idx]}"
            fi
            let this_attempt_num=$this_attempt_num+1
        done #while
        popd >/dev/null  # from $iter_sampl_dir back to $cs_dir
    done
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-stop-tools
    do_roadblock $label "controller" $default_timeout
    echo -e "\nClients/servers stopping tools"
else
    # Sync with your *endpoint* for collector tools because the contoller
    # does not determine and does not know what tool collectors there may be
    label=collector-stop-tools
    do_roadblock $label "endpoint" 86400
    echo -e "\nCollectors stopping tools"
fi
pushd tool-data >/dev/null
while read -u 9 line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done 9<"$tool_stop_cmds"
popd >/dev/null

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-send-data
    do_roadblock $label "controller" $default_timeout
    echo -e "\nClients/servers copying data back to controller"
else
    # Same as collector-stop-tools, sync with endpoint
    label=collector-send-data
    do_roadblock $label "endpoint" $default_timeout
    echo -e "\nCollectors copying data back to controller"
fi

# Send all of the test data to the controller and remove local data
archive_to_controller "$ssh_id_file" "$cs_dir" "$archives_dir/$cs_label-data.tgz"

popd >/dev/null
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-finish
    do_roadblock $label "controller" $default_timeout
    echo -e "\nAll client/server scripts are finished"
else
    # Same as collector-stop-tools, sync with endpoint
    label=collector-script-finish
    do_roadblock $label "endpoint" $default_timeout
    echo -e "\nAll collector scripts are finished"
fi
/bin/rm -rf $cs_dir

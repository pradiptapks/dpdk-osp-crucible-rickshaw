#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash

# This script implements the 'local' endpoint for rickshaw.  It runs 1 or more
# clients and servers for as many benchmark interations/samples as required
# for a single invocation of rickshaw.
# 
# Things that work:
# -validation
# -launching the client/server script in a tmux
#
# Things that don't work or are missing:
# -not using a filesystenm image from workshop
#  -not using a workshop-provided filesystem-image or container-image to either:
#   -use podman to run a container, or
#   -mount the filesystem image (plus /proc & /sys) then chroot to it
#
# Usage:
# local [--validate] --endpoint-opts=client:n-m,o-p,server:n-m,o-p --run-dir --script-dir
#
# If --validate is used all options after client/server will be ignored
# If not using --validate script-dir and --run-dir are required
# The --run-id is rickshaw's run ID
# The --run-dir is rickshaw's current-working-directory,
# The --script-dir is where the client/server scripts are located
# where controller-generated files the endpoint might need will be located

function exit_error() {
    echo "$1"
    exit 1
}

function start_tmux() {
    session_id="$1"
    script="$2"
    if tmux list-sessions 2>/dev/null | awk -F: '{print $1}' | grep -q -- "$session_id"; then
        echo "killing existing tmux session $session_id"
        tmux kill-session -t "$session_id" >/dev/null 2>&1
    fi
    echo "running: tmux new -d -s \"$session_id\" \"$script\""
    tmux new -d -s "$session_id" "$script" 2>&1 "$endpoint_run_dir/>start-tmux.txt"
}

function run_roadblock_follower() {
    local host=$1; shift
    local passwd=$1; shift
    local uuid=$1; shift
    local follower=$1; shift
    if [ -z "$cs_roadblock_opts" ]; then
        return 0
    fi
    echo `date` "Starting roadblock for $uuid"
    local cmd="/usr/bin/roadblock.py --role=follower --redis-server=$host --timeout=300"
    cmd="$cmd --redis-password=$passwd --uuid=$uuid --follower-id=$follower"
    local output=`$cmd 2>&1`
    local rc=$?
    if echo $output | grep -q -- "Received abort message from leader"; then
        rc=3
    fi
    if echo $output | grep -q -- "The roadblock has timed out"; then
        rc=2
    fi
    if [ $rc -gt 0 ]; then
        echo "Roadblock exit code is non-zero: $rc"
    fi
    echo `date` "Completed roadblock for $uuid"
    return $rc
}

echo "#params: $@"
endpoint_name="local"
osruntime="builtin" # to be changed to "chroot" when implemented
longopts="validate,endpoint-opts:,endpoint-label:,run-id:,base-run-dir:,image-id:"
longopts="$longopts,roadblock-server:,roadblock-passwd:,roadblock-id:,osruntime:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    printf -- "\tUnrecognized option specified\n\n"
    exit 1
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --validate)
            do_validate=1
            shift;
            ;;
        --endpoint-opts)
            shift;
            endpoint_opts="$1"
            shift;
            ;;
        --endpoint-label)
            shift;
            endpoint_label="$1"
            shift;
            ;;
        --run-id)
            shift;
            run_id="$1"
            shift;
            ;;
        --base-run-dir)
            shift;
            base_run_dir="$1"
            shift;
            ;;
        --image-id)
            shift;
            image_id="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-server=$roadblock_server"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-passwd=$roadblock_passwd"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            cs_roadblock_opts="$cs_roadblock_opts --roadblock-id=$roadblock_id"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

for opt in `echo $endpoint_opts | sed -e 's/,/ /g'`; do
    arg=`echo $opt | awk -F: '{print $1}'`
    val=`echo $opt | awk -F: '{print $2}'`
    case "$arg" in
        client|server|clients|servers)
            for ids in `echo $val | sed -e 's/,/ /'`; do
                if echo $ids | grep -q -- "-"; then
                    range=`echo $ids | sed 's/-/ /'`
                    for j in `seq $range`; do
                        if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                            clients[$j]="client-$j"
                        elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                            servers[$j]="server-$j"
                        fi
                    done
                else
                    if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                        clients[$ids]="client-$ids"
                    elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                        servers[$ids]="server-$ids"
                    fi
                fi
            done
            ;;
        osruntime)
            case "$val" in
                builtin|chroot|podman)
                    osruntime=$val
                    ;;
                *)
                    exit_error "osruntime $val not supported"
                    ;;
            esac
            ;;
        *)
            exit_error "endpoint options $arg not supported"
            ;;
    esac
done

# Validation just returns what clients and servers would be used
if [ "$do_validate" == 1 ]; then
    if [ ${#clients[@]} -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "server ${!servers[@]}"
    fi
    exit
fi

if [ -z "$roadblock_server" -o -z "$roadblock_passwd" -o -z "$roadblock_id" ]; then
    echo "Not using roadblock to synchronize since some or all options were missing"
    cs_roadblock_opts=""
    rb_do_exit=0
    if [ ${#clients[@]} -gt 1 ]; then
        echo "Refusing to run because roadblock is not being used and number of clients is > 1"
        rb_do_exit=1
    fi
    if [ ${#servers[@]} -gt 0 ]; then
        echo "Refusing to run because roadblock is not being used and servers are used"
        rb_do_exit=1
    fi
    if [ "$rb_do_exit" == "1" ]; then
        exit_error "Exiting do to roadblock/client/server conflict"
    fi
fi


if [ -z "$run_id" ]; then
    exit_error "The run ID was not provided"
fi
if [ -z "$base_run_dir" ]; then
    exit_error "--base-run-dir was not provided"
fi
if [ ! -d "$base_run_dir" ]; then
    exit_error "The run directory [$base_run_dir] does not exist"
fi

config_dir="$base_run_dir/config"
client_server_config_dir="$config_dir/client-server"
client_server_bench_cmds_dir="$client_server_config_dir/bench-cmds"
run_dir="$base_run_dir/run"
client_server_logs_dir="$run_dir/client-server/logs"
endpoint_run_dir="$run_dir/endpoint/$endpoint_label"
client_server_run_script="/usr/local/bin/client-server-script"
mkdir -p $endpoint_run_dir
mkdir -p $client_server_logs_dir

if [ ! -e "$config_dir/rickshaw_id.rsa" ]; then
    exit_error "Could not find $config_dir/rickshaw_id.rsa"
fi

echo osruntime: $osruntime
if [ "$osruntime" == "builtin" ]; then
    # Only the container images already have the client-server-script,
    # so we must copy ourselves
    /bin/cp $client_server_config_dir/client-server-script $client_server_run_script
    # All osruntimes need an ssh-key, but for osruntime "builtin" it can simply be copied here
    /bin/cp -f "$config_dir/rickshaw_id.rsa" /tmp/rickshaw_id.rsa
elif [ "$osruntime" == "chroot" ]; then
    # Delete old container if there is one
    existing_container=`buildah containers --format "{{.ContainerName}}" | grep $endpoint_label`
    if [ ! -z "$existing_container" ]; then
        buildah rm $endpoint_label
    fi
    echo "Adding mount for chroot osruntime"
    container_name=`buildah from --name $endpoint_label $image_id`
    if [ "$container_name" == "$endpoint_label" ]; then
        container_mount=`buildah mount "$container_name"`
        echo "container mount: $container_mount"
        for fs in dev proc sys; do
            mount --verbose --options bind /$fs $container_mount/$fs
        done
        endpoint_run_dir=$container_mount/endpoint-run
        # for chroot osruntime we can also simply copy the ssh key
        /bin/cp -f "$config_dir/rickshaw_id.rsa" $container_mount/tmp/rickshaw_id.rsa
        /bin/cp -f /etc/hosts "$container_mount/etc/"
        /bin/cp -f /etc/resolv.conf "$container_mount/etc/"
    fi
elif [ "$osruntime" == "podman" ]; then
    echo "Creating container for podman osruntime"
    # Delete old container if there is one
    #existing_container=`buildah containers --format "{{.ContainerName}}" | grep $endpoint_label`
    #if [ ! -z "$existing_container" ]; then
        #buildah rm $endpoint_label
    #fi
    # Need to add ssh key with volume mapping
fi

# For each client and server launch the actual script which will run it.

#TODO: get rid of below and copy any necessary files (like a fio.job) based on the benchamrk json
pushd $base_run_dir >/dev/null || exit_error "Could not chdir to $base_run_dir"
find . -mindepth 1 -maxdepth 1 -type f -print | cpio -pdumv "$endpoint_run_dir" 2>&1 || \
    exit_error "Could not copy files from run dir to $endpoint_run_dir"
popd >/dev/null

for this_cs_label in ${clients[@]} ${servers[@]}; do
    this_cs_log_file="$client_server_logs_dir/$this_cs_label.txt"
    base_cmd="$client_server_run_script --rickshaw-host=localhost"
    base_cmd="$base_cmd --endpoint-run-dir=$endpoint_run_dir --cs-label=$this_cs_label $cs_roadblock_opts"
    base_cmd="$base_cmd --base-run-dir=$base_run_dir"
    if [ "$osruntime" == "builtin" ]; then
        cmd="$base_cmd"
        if [ -e "$client_server_run_script" ]; then
            if [ -z "$cs_roadblock_opts" ]; then
                # Only when not using roadblock run the client in the foreground
                echo -e "About to run in foreground:\n$cmd\n"
                $cmd 2>&1 | tee "$this_cs_log_file"
            else
                echo -e "About to run using nohup:\n$cmd\n"
                nohup $cmd 2>&1 >"$this_cs_log_file" &
            fi
        else
            exit_error "[ERROR]could not find script $client_server_run_script"
        fi
    elif [ "$osruntime" == "chroot" ]; then
        echo "using chroot"
        # Note that --endpoint-run value must be hard-coded to /endpoint-run becaue of chroot
        # Same will be true for running podman
        cmd="chroot $container_mount $base_cmd"
        if [ -z "$cs_roadblock_opts" ]; then
            # Only when not using roadblock run the client in the foreground
            $cmd 2>&1 | tee "$this_cs_log_file"
        else
            echo -e "About to run using nohup:\n$cmd\n"
            nohup $cmd 2>&1 >"$this_cs_log_file" &
        fi
    elif [ "$osruntime" == "podman"]; then
        echo doing podman runtime
    fi
done


echo "This endpiont deployed"
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" \
                       "$roadblock_id:endpoint-deploy" "$endpoint_label"
rb_rc=$?
echo roadblock exit code: $rb_rc
if [ $rb_rc -gt 0 ]; then
    exit_error "Exiting: exit code $rb_rc from roadblock $roadblock_id:endpoint-deploy"
fi
# The next roadblock does not sync until the controller (rickshaw/leader) finishes a
# "client/server-finish" sync

# The following is for participating in the roadblock syncs for each benchmark execution.
# The endpoint does not really need to participate in this, but if it does not, it will
# wait on the next roadblock sync (endpoint-move-data) and likely time out when there are
# lots of iterations/samples to run.  Rather than trying to predict a good time period
# to execute all of these tests, it is easier to just participate in the roadblock syncs
# for all of the tests, then run the endpoint-move-data roadblock sync.
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" \
                       "$roadblock_id:client-server-script-start" "$endpoint_label"
rb_rc=$?
echo roadblock exit code: $rb_rc
if [ $rb_rc -gt 0 ]; then
    exit_error "Exiting: exit code $rb_rc from roadblock $roadblock_id:client-server-script-start"
fi
run_roadblock_follower "$roadblock_server" "$roadblock_passwd" \
                       "$roadblock_id:client-server-start-tools" "$endpoint_label"
rb_rc=$?
echo roadblock exit code: $rb_rc
if [ $rb_rc -gt 0 ]; then
    exit_error "Exiting: exit code $rb_rc from roadblock $roadblock_id:client-server-start-tools"
fi
# Process the first client's bench-commands to participate in the roadblocks
if [ ! -e "$client_server_bench_cmds_dir/client/1/start" ]; then
    exit_error "$client_server_bench_cmds_dir/client/1/start not found"
fi
while read line; do
    iter_samp=`echo $line | awk '{print $1}'`
    iter=`echo $iter_samp | awk -F- '{print $1}'`
    samp=`echo $iter_samp | awk -F- '{print $2}'`
    for sync in server-start client-start client-stop server-stop; do
        sync_label="test-${iter}-${samp}:$sync"
        run_roadblock_follower "$roadblock_server" "$roadblock_passwd" \
                               "$roadblock_id:$sync_label" "$endpoint_label"
        rb_rc=$?
        echo roadblock $sync_label exit code: $rb_rc
        if [ $rb_rc -eq 3 ]; then
            echo -e "\nNon-zero exit code from iteration $iter, sample $samp"
            echo -e "\nWill not run remaining tests\n"
            break
        fi
        if [ $rb_rc -eq 2 ]; then
            exit_error "Exiting: exit code 2 (timeout) from roadblock iteration $iter, sample $samp"
        fi
    done
done < "$client_server_bench_cmds_dir/client/1/start" # We use "1" because we can use any client file
                                                      # and we know "1" will always be present
echo "Out of test loop"
for id in client-server-stop-tools client-server-send-data client-server-script-finish \
         endpoint-move-data endpoint-finish endpoint-really-finish; do
    run_roadblock_follower "$roadblock_server" "$roadblock_passwd" \
                           "$roadblock_id:$id" "$endpoint_label"
    rb_rc=$?
    echo roadblock $id exit code: $rb_rc
    if [ $rb_rc -gt 0 ]; then
        exit_error "Exiting: exit code $rb_rc from roadblock $roadblock_id:$id"
    fi
done

if [ "$osruntime" == "chroot" ]; then
    for fs in dev proc sys; do
         umount $container_mount/$fs
    done
    echo "Removing mount $container_name for chroot osruntime"
    buildah unmount "$container_name"
    echo "Removing container $container_name for chroot runtime"
    buildah rm "$container_name"
fi
# At this point the endpoint is "deployed" and can exit
echo "Exiting local endpoint script"
exit 0


